const PDFDocument = require('pdfkit');
const moment = require('moment');

/**
 * Generate PDF export for transaction history
 */
async function generatePDF(transactions, options) {
  const { address, startDate, endDate } = options;

  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margin: 50
      });

      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));

      // Add header
      addHeader(doc, address, startDate, endDate);

      // Add summary section
      addSummary(doc, transactions);

      // Add transactions table
      addTransactionsTable(doc, transactions);

      // Add footer
      addFooter(doc);

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Add header to PDF
 */
function addHeader(doc, address, startDate, endDate) {
  // Title
  doc.fontSize(24)
     .font('Helvetica-Bold')
     .text('Solana Transaction Report', { align: 'center' })
     .moveDown(0.5);

  // Subtitle
  doc.fontSize(14)
     .font('Helvetica')
     .text('Tax-Friendly Transaction History', { align: 'center' })
     .moveDown(1);

  // Report details
  doc.fontSize(12)
     .font('Helvetica-Bold')
     .text('Report Details:', { underline: true })
     .moveDown(0.3);

  doc.fontSize(10)
     .font('Helvetica')
     .text(`Wallet Address: ${address}`)
     .text(`Date Range: ${startDate.toDateString()} - ${endDate.toDateString()}`)
     .text(`Generated: ${new Date().toLocaleString()}`)
     .moveDown(1);
}

/**
 * Add summary section
 */
function addSummary(doc, transactions) {
  const summary = calculateSummary(transactions);

  doc.fontSize(14)
     .font('Helvetica-Bold')
     .text('Summary', { underline: true })
     .moveDown(0.5);

  // Summary table
  const summaryData = [
    ['Total Transactions', summary.totalTransactions.toString()],
    ['Successful Transactions', summary.successfulTransactions.toString()],
    ['Failed Transactions', summary.failedTransactions.toString()],
    ['Total Fees (SOL)', (summary.totalFees / 1e9).toFixed(9)],
    ['Total Value (USD)', `$${summary.totalValue.toFixed(2)}`]
  ];

  createTable(doc, summaryData, ['Metric', 'Value'], 200);
  doc.moveDown(1);
}

/**
 * Add transactions table
 */
function addTransactionsTable(doc, transactions) {
  doc.fontSize(14)
     .font('Helvetica-Bold')
     .text('Transaction Details', { underline: true })
     .moveDown(0.5);

  if (transactions.length === 0) {
    doc.fontSize(10)
       .font('Helvetica')
       .text('No transactions found for the specified date range.')
       .moveDown(1);
    return;
  }

  // Prepare table data
  const tableData = transactions.map(tx => [
    moment(tx.blockTime * 1000).format('YYYY-MM-DD'),
    categorizeTransactionType(tx.type),
    tx.token || 'SOL',
    formatAmount(tx.amount),
    `$${formatPrice(tx.price)}`,
    `$${formatPrice(tx.value)}`,
    tx.status
  ]);

  // Table headers
  const headers = ['Date', 'Type', 'Token', 'Amount', 'Price (USD)', 'Value (USD)', 'Status'];

  // Create table
  createTable(doc, tableData, headers, 500);
}

/**
 * Create a table in PDF
 */
function createTable(doc, data, headers, maxWidth) {
  const tableTop = doc.y;
  const tableLeft = doc.x;
  const colWidth = maxWidth / headers.length;
  const rowHeight = 20;

  // Draw headers
  doc.fontSize(10)
     .font('Helvetica-Bold');

  headers.forEach((header, i) => {
    const x = tableLeft + (i * colWidth);
    const y = tableTop;
    
    doc.rect(x, y, colWidth, rowHeight)
       .stroke()
       .text(header, x + 5, y + 5, { width: colWidth - 10 });
  });

  // Draw data rows
  doc.fontSize(8)
     .font('Helvetica');

  data.forEach((row, rowIndex) => {
    const y = tableTop + ((rowIndex + 1) * rowHeight);
    
    row.forEach((cell, colIndex) => {
      const x = tableLeft + (colIndex * colWidth);
      
      doc.rect(x, y, colWidth, rowHeight)
         .stroke()
         .text(cell.toString(), x + 5, y + 5, { width: colWidth - 10 });
    });
  });

  doc.y = tableTop + ((data.length + 1) * rowHeight) + 10;
}

/**
 * Add footer to PDF
 */
function addFooter(doc) {
  const pageCount = doc.bufferedPageRange().count;
  
  for (let i = 0; i < pageCount; i++) {
    doc.switchToPage(i);
    
    const footerText = `Page ${i + 1} of ${pageCount} | Generated by Solax Tax Tool | ${new Date().toLocaleDateString()}`;
    
    doc.fontSize(8)
       .font('Helvetica')
       .text(footerText, 50, doc.page.height - 50, { 
         width: doc.page.width - 100,
         align: 'center'
       });
  }
}

/**
 * Calculate summary statistics
 */
function calculateSummary(transactions) {
  return {
    totalTransactions: transactions.length,
    successfulTransactions: transactions.filter(tx => tx.status === 'success').length,
    failedTransactions: transactions.filter(tx => tx.status === 'failed').length,
    totalFees: transactions.reduce((sum, tx) => sum + (tx.fee || 0), 0),
    totalValue: transactions.reduce((sum, tx) => sum + (tx.value || 0), 0)
  };
}

/**
 * Categorize transaction type for tax purposes
 */
function categorizeTransactionType(type) {
  const typeMap = {
    'buy': 'Purchase',
    'sell': 'Sale',
    'swap': 'Swap',
    'transfer': 'Transfer',
    'liquidity': 'Liquidity',
    'airdrop': 'Airdrop',
    'stake': 'Staking',
    'unstake': 'Unstaking',
    'unknown': 'Other'
  };

  return typeMap[type] || 'Other';
}

/**
 * Format amount for PDF
 */
function formatAmount(amount) {
  if (!amount || amount === 0) return '0';
  return parseFloat(amount).toFixed(8);
}

/**
 * Format price for PDF
 */
function formatPrice(price) {
  if (!price || price === 0) return '0.00';
  return parseFloat(price).toFixed(2);
}

module.exports = {
  generatePDF,
  addHeader,
  addSummary,
  addTransactionsTable,
  createTable,
  addFooter,
  calculateSummary,
  categorizeTransactionType,
  formatAmount,
  formatPrice
}; 